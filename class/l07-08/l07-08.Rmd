---
title: "l07-08"
author: "TA"
date: "2022/5/10"
output: html_document
---

```{r setup, include=FALSE}
knitr::opts_chunk$set(echo = TRUE)
```

```{r chapter3.2.3}
##libraries
library(sf)
library(raster)
library(dplyr)
library(stringr) # for working with strings (pattern matching)
library(tidyr)   # for unite() and separate()
library(spData)

#worldデータとcoffee生産データを統合する
world
coffee_data
world_coffee = left_join(world, coffee_data, by = "name_long")
class(world_coffee)
world_coffee

plot(world_coffee["coffee_production_2017"])

world_coffee_inner <- inner_join(world, coffee_data)
world_coffee_inner
plot(world_coffee_inner["coffee_production_2017"])
```


```{r chapter 3.2.4}
world_new = world # do not overwrite our original data
world_new$pop_dens = world_new$pop / world_new$area_km2
world_new

world_new2 <- world %>% mutate(pop_dens = pop/area_km2)

world %>% transmute(pop_dens = pop/area_km2)

world %>% transmute(pop_dens = pop/area_km2) %>% st_drop_geometry()

```

```{r chapter 3.3}
elev = raster(nrows = 6, ncols = 6, res = 0.5,
              xmn = -1.5, xmx = 1.5, ymn = -1.5, ymx = 1.5,
              vals = 1:36)

# row 1, column 1
elev[1, 1]
# cell ID 1
elev[1]

elev[1, 1] = 0
elev[]
```

```{r chapter4.2.1}
#mapに表示させる
canterbury = nz %>% filter(Name == "Canterbury")
canterbury_height = nz_height[canterbury, ]

library(tmap)
p_hpnz1 = tm_shape(nz) + tm_polygons(col = "white") +
  tm_shape(nz_height) + tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in New Zealand", main.title.size = 1,
            bg.color = "lightblue")
p_hpnz2 = tm_shape(nz) + tm_polygons(col = "white") +
  tm_shape(canterbury) + tm_fill(col = "gray") + 
  tm_shape(canterbury_height) + tm_symbols(shape = 2, col = "red", size = 0.25) +
  tm_layout(main.title = "High points in Canterbury", main.title.size = 1,
            bg.color = "lightblue")
tmap_arrange(p_hpnz1, p_hpnz2, ncol = 2)
```

```{r chapter4.2.2}
# create a polygon
a_poly = st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a = st_sfc(a_poly)
# create a line
l_line = st_linestring(x = matrix(c(-1, -1, -0.5, 1), ncol = 2))
l = st_sfc(l_line)
# create points
p_matrix = matrix(c(0.5, 1, -1, 0, 0, 1, 0.5, 1), ncol = 2)
p_multi = st_multipoint(x = p_matrix)
p = st_cast(st_sfc(p_multi), "POINT")

par(pty = "s")
plot(a, border = "red", col = "gray", axes = TRUE)
plot(l, add = TRUE)
plot(p, add = TRUE, lab = 1:4)
text(p_matrix[, 1] + 0.04, p_matrix[, 2] - 0.06, 1:4, cex = 1.3)

st_intersects(p, a)
#> Sparse geometry binary ..., where the predicate was `intersects'
#> 1: 1
#> 2: 1
#> 3: (empty)
#> 4: (empty)

#
st_intersects(p, a, sparse = FALSE)
#
st_disjoint(p, a, sparse = FALSE)[, 1]
#中にあるか
st_within(p, a, sparse = FALSE)[, 1]
#触れているか
st_touches(p, a, sparse = FALSE)[, 1]

sel = st_is_within_distance(p, a, dist = 0.9) # can only return a sparse matrix
lengths(sel) > 0

st_overlaps(p, a, sparse = FALSE)
st_covers(p, a, sparse = FALSE)
st_covered_by(p, a, sparse = FALSE)

st_contains(a, p[2, ], sparse = TRUE)


```

```{r chapter4.2.2-2}
# starting simpler so commented
a1 = st_polygon(list(rbind(c(-1, -1), c(1, -1), c(1, 1), c(-1, -1))))
a2 = st_polygon(list(rbind(c(2, 0), c(2, 2), c(3, 2), c(3, 0), c(2, 0))))
a = st_sfc(a1, a2)

b1 = a1 * 0.5
b2 = a2 * 0.4 + c(1, 0.5)
b = st_sfc(b1, b2)

l1 = st_linestring(x = matrix(c(0, 3, -1, 1), , 2))
l2 = st_linestring(x = matrix(c(-1, -1, -0.5, 1), , 2))
l = st_sfc(l1, l2)

p = st_multipoint(x = matrix(c(0.5, 1, -1, 0, 1, 0.5), , 2))

plot(a, border = "red", axes = TRUE)
plot(b, border = "green", add = TRUE)
plot(l, add = TRUE)
plot(p, add = TRUE)
```

```{r chapter4.2.3}
set.seed(2018) # set seed for reproducibility
(bb_world = st_bbox(world)) # the world's bounds
random_df = tibble(
  x = runif(n = 10, min = bb_world[1], max = bb_world[3]),
  y = runif(n = 10, min = bb_world[2], max = bb_world[4])
)
random_points = random_df %>% 
  st_as_sf(coords = c("x", "y")) %>% # set coordinates
  st_set_crs(4326) # set geographic CRS

world_random = world[random_points, ]
nrow(world_random)
random_joined = st_join(random_points, world["name_long"])

#source("./code/04-spatial-join.R")

#tmap_arrange(jm1, jm2, jm3, jm4, nrow = 2, ncol = 2)

#plot(st_geometry(cycle_hire), col = "blue")
#plot(st_geometry(cycle_hire_osm), add = TRUE, pch = 3, col = "red")

#any(st_touches(cycle_hire, cycle_hire_osm, sparse = FALSE))

#sum(st_geometry(cycle_hire) %in% st_geometry(cycle_hire_osm))
#sum(st_coordinates(cycle_hire)[, 1] %in% st_coordinates(cycle_hire_osm)[, 1])
```

```{r}

```





